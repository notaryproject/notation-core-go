package signature

import "fmt"

// Envelope provides functions to basic functions to manipulate signatures
type Envelope interface {
	Sign(req *SignRequest) ([]byte, error)
	Verify() (*Payload, *SignerInfo, error)
	Payload() (*Payload, error)
	SignerInfo() (*SignerInfo, error)
}

// NewEnvelopeFunc defines a function to create a new Envelope
type NewEnvelopeFunc func() Envelope

// ParseEnvelopeFunc defines a function to create a new Envelope with given 
// envelope bytes
type ParseEnvelopeFunc func([]byte) (Envelope, error)

type envelopeFunc struct {
	newFunc   NewEnvelopeFunc
	parseFunc ParseEnvelopeFunc
}

var envelopeFuncs = make(map[string]envelopeFunc)

// RegisterEnvelopeType registers newFunc and parseFunc for the given mediaType
// Thoese functions are intended to be called when creating a new envelope
func RegisterEnvelopeType(mediaType string, newFunc NewEnvelopeFunc, parseFunc ParseEnvelopeFunc) error {
	if newFunc == nil || parseFunc == nil {
		return fmt.Errorf("required functions not provided")
	}
	
	envelopeFuncs[mediaType] = envelopeFunc{
		newFunc:   newFunc,
		parseFunc: parseFunc,
	}
	return nil
}

// NewEnvelope returns an envelope of given media type
func NewEnvelope(mediaType string) (Envelope, error) {
	envelopeFunc, ok := envelopeFuncs[mediaType]
	if !ok {
		return nil, fmt.Errorf("envelope is not set for type: %s", mediaType)
	}
	return envelopeFunc.newFunc(), nil
}

// NewEnvelope returns an envelope generated by given bytes and media type
func ParseEnvelope(mediaType string, envelopeBytes []byte) (Envelope, error) {
	envelopeFunc, ok := envelopeFuncs[mediaType]
	if !ok {
		return nil, fmt.Errorf("envelope is not set for type: %s", mediaType)
	}
	return envelopeFunc.parseFunc(envelopeBytes)
}